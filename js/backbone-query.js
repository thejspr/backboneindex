// Generated by CoffeeScript 1.3.3
/*
Backbone Query - A lightweight query API for Backbone Collections
(c)2012 - Dave Tonge
May be freely distributed according to MIT license.
*/

var __slice = [].slice,
  __hasProp = {}.hasOwnProperty,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

(function(define) {
  return define('backbone-query', function(require, exports) {
    var Backbone, detect, filter, getCache, getSortedModels, getType, iterator, makeObj, pageModels, parseQuery, parseSubQuery, performQuery, processQuery, reject, runQuery, sortModels, testModelAttribute, testQueryValue, _;
    _ = require('underscore');
    Backbone = require('backbone');
    /* UTILS
    */

    filter = function(array, test) {
      var val, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = array.length; _i < _len; _i++) {
        val = array[_i];
        if (test(val)) {
          _results.push(val);
        }
      }
      return _results;
    };
    reject = function(array, test) {
      var val, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = array.length; _i < _len; _i++) {
        val = array[_i];
        if (!test(val)) {
          _results.push(val);
        }
      }
      return _results;
    };
    detect = function(array, test) {
      var val, _i, _len;
      for (_i = 0, _len = array.length; _i < _len; _i++) {
        val = array[_i];
        if (test(val)) {
          return true;
        }
      }
      return false;
    };
    makeObj = function() {
      var args, current, key, o, val;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      o = {};
      current = o;
      while (args.length) {
        key = args.shift();
        val = (args.length === 1 ? args.shift() : {});
        current = current[key] = val;
      }
      return o;
    };
    getType = function(item) {
      if (_.isRegExp(item)) {
        return "$regex";
      }
      if (_.isDate(item)) {
        return "$date";
      }
      if (_.isObject(item) && !_.isArray(item)) {
        return "object";
      }
      if (_.isArray(item)) {
        return "array";
      }
      if (_.isString(item)) {
        return "string";
      }
      if (_.isNumber(item)) {
        return "number";
      }
      if (_.isBoolean(item)) {
        return "boolean";
      }
      if (_.isFunction(item)) {
        return "function";
      }
      return false;
    };
    /*
      Function to parse raw queries
      @param {mixed} raw query
      @return {array} parsed query
    
      Allows queries of the following forms:
      query
        name: "test"
        id: $gte: 10
    
      query [
        {name:"test"}
        {id:$gte:10}
      ]
    */

    parseSubQuery = function(rawQuery) {
      var key, o, paramType, q, query, queryArray, queryParam, type, val, value, _i, _len, _results;
      if (_.isArray(rawQuery)) {
        queryArray = rawQuery;
      } else {
        queryArray = (function() {
          var _results;
          _results = [];
          for (key in rawQuery) {
            if (!__hasProp.call(rawQuery, key)) continue;
            val = rawQuery[key];
            _results.push(makeObj(key, val));
          }
          return _results;
        })();
      }
      _results = [];
      for (_i = 0, _len = queryArray.length; _i < _len; _i++) {
        query = queryArray[_i];
        for (key in query) {
          if (!__hasProp.call(query, key)) continue;
          queryParam = query[key];
          o = {
            key: key
          };
          paramType = getType(queryParam);
          switch (paramType) {
            case "$regex":
            case "$date":
              o.type = paramType;
              o.value = queryParam;
              break;
            case "object":
              if (key === "$and" || key === "$or" || key === "$nor" || key === "$not") {
                o.value = parseSubQuery(queryParam);
                o.type = key;
                o.key = null;
              } else {
                for (type in queryParam) {
                  value = queryParam[type];
                  if (testQueryValue(type, value)) {
                    o.type = type;
                    switch (type) {
                      case "$elemMatch":
                      case "$relationMatch":
                        o.value = parseQuery(value);
                        break;
                      case "$computed":
                        q = makeObj(key, value);
                        o.value = parseSubQuery(q);
                        break;
                      default:
                        o.value = value;
                    }
                  }
                }
              }
              break;
            default:
              o.type = "$equal";
              o.value = queryParam;
          }
          if ((o.type === "$equal") && (paramType === "object" || paramType === "array")) {
            o.type = "$oEqual";
          }
        }
        _results.push(o);
      }
      return _results;
    };
    testQueryValue = function(type, value) {
      switch (type) {
        case "$in":
        case "$nin":
        case "$all":
        case "$any":
          return _(value).isArray();
        case "$size":
          return _(value).isNumber();
        case "$regex":
          return _(value).isRegExp();
        case "$like":
        case "$likeI":
          return _(value).isString();
        case "$between":
          return _(value).isArray() && (value.length === 2);
        case "$cb":
          return _(value).isFunction();
        default:
          return true;
      }
    };
    testModelAttribute = function(type, value) {
      switch (type) {
        case "$like":
        case "$likeI":
        case "$regex":
          return _(value).isString();
        case "$contains":
        case "$all":
        case "$any":
        case "$elemMatch":
          return _(value).isArray();
        case "$size":
          return _(value).isArray() || _(value).isString();
        case "$in":
        case "$nin":
          return value != null;
        case "$relationMatch":
          return (value != null) && value.models;
        default:
          return true;
      }
    };
    performQuery = function(type, value, attr, model, key) {
      switch (type) {
        case "$equal":
          if (_(attr).isArray()) {
            return __indexOf.call(attr, value) >= 0;
          } else {
            return attr === value;
          }
          break;
        case "$oEqual":
          return _(attr).isEqual(value);
        case "$contains":
          return __indexOf.call(attr, value) >= 0;
        case "$ne":
          return attr !== value;
        case "$lt":
          return attr < value;
        case "$gt":
          return attr > value;
        case "$lte":
          return attr <= value;
        case "$gte":
          return attr >= value;
        case "$between":
          return (value[0] < attr && attr < value[1]);
        case "$in":
          return __indexOf.call(value, attr) >= 0;
        case "$nin":
          return __indexOf.call(value, attr) < 0;
        case "$all":
          return _(value).all(function(item) {
            return __indexOf.call(attr, item) >= 0;
          });
        case "$any":
          return _(attr).any(function(item) {
            return __indexOf.call(value, item) >= 0;
          });
        case "$size":
          return attr.length === value;
        case "$exists":
        case "$has":
          return (attr != null) === value;
        case "$like":
          return attr.indexOf(value) !== -1;
        case "$likeI":
          return attr.toLowerCase().indexOf(value.toLowerCase()) !== -1;
        case "$regex":
          return value.test(attr);
        case "$cb":
          return value.call(model, attr);
        case "$elemMatch":
          return (runQuery(attr, value, "elemMatch")).length > 0;
        case "$relationMatch":
          return (runQuery(attr.models, value, "relationMatch")).length > 0;
        case "$computed":
          return iterator([model], value, false, detect, "computed");
        case "$and":
        case "$or":
        case "$nor":
        case "$not":
          return (processQuery[type]([model], value)).length === 1;
        default:
          return false;
      }
    };
    iterator = function(models, query, andOr, filterFunction, itemType) {
      if (itemType == null) {
        itemType = false;
      }
      return filterFunction(models, function(model) {
        var attr, q, test, _i, _len;
        for (_i = 0, _len = query.length; _i < _len; _i++) {
          q = query[_i];
          attr = (function() {
            switch (itemType) {
              case "elemMatch":
                return model[q.key];
              case "computed":
                return model[q.key]();
              default:
                return model.get(q.key);
            }
          })();
          test = testModelAttribute(q.type, attr);
          if (test) {
            test = performQuery(q.type, q.value, attr, model, q.key);
          }
          if (andOr === test) {
            return andOr;
          }
        }
        return !andOr;
      });
    };
    processQuery = {
      $and: function(models, query, itemType) {
        return iterator(models, query, false, filter, itemType);
      },
      $or: function(models, query, itemType) {
        return iterator(models, query, true, filter, itemType);
      },
      $nor: function(models, query, itemType) {
        return iterator(models, query, true, reject, itemType);
      },
      $not: function(models, query, itemType) {
        return iterator(models, query, false, reject, itemType);
      }
    };
    parseQuery = function(query) {
      var compoundKeys, compoundQuery, key, queryKeys, type, val;
      queryKeys = _(query).keys();
      compoundKeys = ["$and", "$not", "$or", "$nor"];
      compoundQuery = _.intersection(compoundKeys, queryKeys);
      if (compoundQuery.length === 0) {
        return [
          {
            type: "$and",
            parsedQuery: parseSubQuery(query)
          }
        ];
      } else {
        if (compoundQuery.length !== queryKeys.length) {
          if (__indexOf.call(compoundQuery, "$and") < 0) {
            query.$and = {};
            compoundQuery.unshift("$and");
          }
          for (key in query) {
            if (!__hasProp.call(query, key)) continue;
            val = query[key];
            if (!(__indexOf.call(compoundKeys, key) < 0)) {
              continue;
            }
            query.$and[key] = val;
            delete query[key];
          }
        }
        return (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = compoundQuery.length; _i < _len; _i++) {
            type = compoundQuery[_i];
            _results.push({
              type: type,
              parsedQuery: parseSubQuery(query[type])
            });
          }
          return _results;
        })();
      }
    };
    runQuery = function(items, query, itemType) {
      var reduceIterator;
      if (!itemType) {
        query = parseQuery(query);
      }
      reduceIterator = function(memo, queryItem) {
        return processQuery[queryItem.type](memo, queryItem.parsedQuery, itemType);
      };
      return _.reduce(query, reduceIterator, items);
    };
    getCache = function(collection, query, options) {
      var cache, models, queryString, _ref;
      queryString = JSON.stringify(query);
      cache = (_ref = collection._queryCache) != null ? _ref : collection._queryCache = {};
      models = cache[queryString];
      if (!models) {
        models = getSortedModels(collection, query, options);
        cache[queryString] = models;
      }
      return models;
    };
    getSortedModels = function(collection, query, options) {
      var models;
      models = runQuery(collection.models, query);
      if (options.sortBy) {
        models = sortModels(models, options);
      }
      return models;
    };
    sortModels = function(models, options) {
      if (_(options.sortBy).isString()) {
        models = _(models).sortBy(function(model) {
          return model.get(options.sortBy);
        });
      } else if (_(options.sortBy).isFunction()) {
        models = _(models).sortBy(options.sortBy);
      }
      if (options.order === "desc") {
        models = models.reverse();
      }
      return models;
    };
    pageModels = function(models, options) {
      var end, sliced_models, start, total_pages;
      if (options.offset) {
        start = options.offset;
      } else if (options.page) {
        start = (options.page - 1) * options.limit;
      } else {
        start = 0;
      }
      end = start + options.limit;
      sliced_models = models.slice(start, end);
      if (options.pager && _.isFunction(options.pager)) {
        total_pages = Math.ceil(models.length / options.limit);
        options.pager(total_pages, sliced_models);
      }
      return sliced_models;
    };
    Backbone.QueryCollection = Backbone.Collection.extend({
      query: function(query, options) {
        var models;
        if (options == null) {
          options = {};
        }
        if (options.cache) {
          models = getCache(this, query, options);
        } else {
          models = getSortedModels(this, query, options);
        }
        if (options.limit) {
          models = pageModels(models, options);
        }
        return models;
      },
      findOne: function(query) {
        return this.query(query)[0];
      },
      whereBy: function(params, options) {
        if (options == null) {
          options = {};
        }
        return new this.constructor(this.query(params, options));
      },
      resetQueryCache: function() {
        return this._queryCache = {};
      }
    });
    return exports.QueryCollection = Backbone.QueryCollection;
  });
}).call(this, typeof define === 'function' && define.amd ? define : function(id, factory) {
  if (typeof exports !== 'undefined') {
    factory((function(id) {
      return require(id);
    }), exports);
  } else {
    factory((function(id) {
      return this[id === 'underscore' ? '_' : 'Backbone'];
    }), {});
  }
});
